<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Deep Void - Ethereal Mood</title>
    <style>
        /* ì™„ì „í•œ ì•”í‘ ë°°ê²½ */
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: sans-serif; }

        .home-btn {
            position: absolute; top: 30px; left: 30px;
            color: rgba(255, 255, 255, 0.5); text-decoration: none;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px; border-radius: 30px;
            transition: all 0.3s; font-size: 0.8rem; text-transform: uppercase;
            mix-blend-mode: difference; z-index: 100;
        }
        .home-btn:hover { background: white; color: black; box-shadow: 0 0 15px white; }

        .controls {
            position: absolute; bottom: 50px; left: 50%;
            transform: translateX(-50%); z-index: 100;
            display: flex; gap: 10px;
            background: rgba(10, 10, 10, 0.8);
            padding: 15px; border-radius: 50px;
            border: 1px solid rgba(50, 50, 50, 0.5);
            backdrop-filter: blur(10px);
        }

        button {
            background: transparent; border: none;
            color: #888; cursor: pointer;
            font-size: 0.85rem; text-transform: uppercase;
            padding: 8px 12px; border-radius: 20px; transition: all 0.3s;
        }
        button:hover { color: white; background: rgba(255,255,255,0.1); }
        button:active { transform: scale(0.95); }

        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #333; letter-spacing: 5px; animation: pulse 2s infinite; pointer-events: none;}
        @keyframes pulse { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>

<a href="/" class="home-btn">â† Main Page</a>
<div id="loading">SYSTEM LOADING...</div>

<div class="controls">
    <button onclick="changeMood('fire')">ğŸ”¥ Passion</button>
    <button onclick="changeMood('ocean')">ğŸŒŠ Ocean</button>
    <button onclick="changeMood('forest')">ğŸŒ¿ Nature</button>
    <button onclick="changeMood('magic')">ğŸ”® Magic</button>
    <button onclick="changeMood('void')">âš« Void</button>
</div>

<script>
    // 1. Scene ì„¤ì •
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.04);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 4.2;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.8;
    document.body.appendChild(renderer.domElement);

    // 2. ì‰ì´ë” (GLSL)
    const vertexShader = `
        varying vec2 vUv;
        varying float vNoise;
        varying vec3 vNormal;

        uniform float uTime;
        uniform float uDistortion;

        // Noise Logic
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            vUv = uv;
            vNormal = normal;
            float noise = snoise(position * 1.5 + uTime * 0.4);
            vNoise = noise;
            vec3 newPos = position + normal * noise * uDistortion;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
        }
    `;

    const fragmentShader = `
        uniform vec3 uColorA;
        uniform vec3 uColorB;
        uniform float uTime;
        uniform float uFresnelPower;
        uniform float uFresnelIntensity;
        uniform float uIsVoid; // 0.0 ~ 1.0 ìŠ¤ìœ„ì¹˜

        varying float vNoise;
        varying vec3 vNormal;
        varying vec2 vUv;

        void main() {
            // [A] ì¼ë°˜ ëª¨ë“œ (Color Therapy)
            vec3 normalColor = mix(uColorA, uColorB, vNoise * 0.5 + 0.5);
            vec3 viewDir = normalize(cameraPosition - vNormal);
            float fresnel = pow(1.0 - dot(viewDir, vNormal), uFresnelPower);
            vec3 normalFinal = normalColor + (normalColor * fresnel * uFresnelIntensity);

            // [B] Void ëª¨ë“œ (Black Sphere + Smooth Pulsing Warm Light Spots)
            vec3 voidBase = vec3(0.0); // ì™„ì „ ê²€ì • ë°°ê²½

            // 1. ë¹›ì˜ ìœ„ì¹˜ ì›€ì§ì„ (ì‹œê°„ì— ë”°ë¼ UV ì¢Œí‘œìƒì—ì„œ ë¶€ë“œëŸ½ê²Œ ì›€ì§ì´ëŠ” ë‘ ê°œì˜ ì )
            // sin/cos ì£¼ê¸°ë¥¼ ë‹¤ë¥´ê²Œ í•´ì„œ ë¶ˆê·œì¹™í•œ ì›€ì§ì„ ìƒì„±
            vec2 lightPos1 = vec2(sin(uTime * 0.4) * 0.4 + 0.5, cos(uTime * 0.5) * 0.3 + 0.5);
            vec2 lightPos2 = vec2(cos(uTime * 0.6) * 0.3 + 0.5, sin(uTime * 0.7) * 0.4 + 0.5);

            // 2. í˜„ì¬ í”½ì…€ ìœ„ì¹˜ì™€ ë¹› ìœ„ì¹˜ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
            float d1 = distance(vUv, lightPos1);
            float d2 = distance(vUv, lightPos2);

            // 3. ë¹›ì˜ ì˜ì—­ ë§Œë“¤ê¸° (smoothstepìœ¼ë¡œ ì•„ì£¼ ë¶€ë“œëŸ¬ìš´ ê²½ê³„ ìƒì„±)
            // 0.25 ë°˜ê²½ ë‚´ì—ì„œ ì¤‘ì‹¬(0.0)ìœ¼ë¡œ ê°ˆìˆ˜ë¡ ë°ì•„ì§
            float spot1 = smoothstep(0.25, 0.0, d1);
            float spot2 = smoothstep(0.2, 0.0, d2);

            // 4. ì „ì²´ì ì¸ ë°ê¸° ë§¥ë°• (ìˆ¨ì‰¬ë“¯ì´ ì²œì²œíˆ)
            float globalPulse = sin(uTime * 1.0) * 0.4 + 0.6; // 0.2 ~ 1.0 ë²”ìœ„ë¡œ ì²œì²œíˆ ë³€í™”

            // 5. ìµœì¢… ë¹› ê°•ë„ ê²°í•©
            float totalLightIntensity = (spot1 + spot2 * 0.7) * globalPulse;

            // 6. ìƒ‰ìƒ ì •ì˜ (ìš”ì²­í•˜ì‹  'ì€ì€í•œ ë…¸ë€ ëŠë‚Œì˜ í°ìƒ‰')
            vec3 warmLightColor = vec3(1.0, 0.96, 0.82);

            // 7. ìµœì¢… Void ìƒ‰ìƒ ê³„ì‚° (ê°•ë„ ì¡°ì ˆ)
            vec3 voidFinal = voidBase + warmLightColor * totalLightIntensity * uFresnelIntensity * 0.9;

            // [Mix] uIsVoid ê°’ì— ë”°ë¼ ì¼ë°˜ëª¨ë“œì™€ Voidëª¨ë“œ ë¶€ë“œëŸ½ê²Œ ì „í™˜
            gl_FragColor = vec4(mix(normalFinal, voidFinal, uIsVoid), 1.0);
        }
    `;

    // 3. Object
    const geometry = new THREE.IcosahedronGeometry(1.4, 60);
    const material = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        uniforms: {
            uTime: { value: 0 },
            uDistortion: { value: 0.4 },
            uColorA: { value: new THREE.Color('#ff0000') },
            uColorB: { value: new THREE.Color('#0000ff') },
            uFresnelPower: { value: 2.0 },
            uFresnelIntensity: { value: 1.0 },
            uIsVoid: { value: 0.0 } // 0: Normal, 1: Void
        },
        wireframe: false
    });

    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    // ë°°ê²½ ë³„
    const starGeo = new THREE.BufferGeometry();
    const starCount = 3000;
    const starPos = new Float32Array(starCount * 3);
    for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random()-0.5)*40;
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({color: 0x888888, size: 0.03, transparent: true, opacity: 0.6});
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // 4. Bloom
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));

    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 1.0;
    bloomPass.radius = 0.5;
    composer.addPass(bloomPass);

    document.getElementById('loading').style.display = 'none';

    // 5. ë¬´ë“œ ë°ì´í„°
    const moods = {
        'fire':   { a: '#ff2200', b: '#ffcc00', dist: 0.5, fp: 2.0, fi: 1.2, isVoid: 0.0 },
        'ocean':  { a: '#001133', b: '#00aaff', dist: 0.3, fp: 3.0, fi: 1.5, isVoid: 0.0 },
        'forest': { a: '#003311', b: '#00ff66', dist: 0.35, fp: 2.5, fi: 1.0, isVoid: 0.0 },
        'magic':  { a: '#440044', b: '#ff00ff', dist: 0.6, fp: 2.0, fi: 1.3, isVoid: 0.0 },
        // Void ì„¤ì •: ì™œê³¡ ìµœì†Œí™”(0.02), isVoid í™œì„±í™”(1.0), fi(ê°•ë„)ëŠ” ì ë‹¹íˆ
        'void':   { a: '#000000', b: '#000000', dist: 0.15, fp: 1.0, fi: 1.5, isVoid: 1.0 }
    };

    const targetState = {
        colorA: new THREE.Color('#440044'),
        colorB: new THREE.Color('#ff00ff'),
        dist: 0.6, fp: 2.0, fi: 1.3, isVoid: 0.0
    };

    window.onload = () => changeMood('magic');

    window.changeMood = function(moodName) {
        const m = moods[moodName];
        if(!m) return;
        targetState.colorA.set(m.a);
        targetState.colorB.set(m.b);
        targetState.dist = m.dist;
        targetState.fp = m.fp;
        targetState.fi = m.fi;
        targetState.isVoid = m.isVoid;
    };

    // 6. ì• ë‹ˆë©”ì´ì…˜
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        material.uniforms.uTime.value = time;

        const lerpSpeed = 0.05;
        material.uniforms.uColorA.value.lerp(targetState.colorA, lerpSpeed);
        material.uniforms.uColorB.value.lerp(targetState.colorB, lerpSpeed);
        material.uniforms.uDistortion.value += (targetState.dist - material.uniforms.uDistortion.value) * lerpSpeed;
        material.uniforms.uFresnelPower.value += (targetState.fp - material.uniforms.uFresnelPower.value) * lerpSpeed;
        material.uniforms.uFresnelIntensity.value += (targetState.fi - material.uniforms.uFresnelIntensity.value) * lerpSpeed;

        // Void ëª¨ë“œ ìŠ¤ìœ„ì¹­
        material.uniforms.uIsVoid.value += (targetState.isVoid - material.uniforms.uIsVoid.value) * lerpSpeed;

        sphere.rotation.y += 0.003;
        stars.rotation.y -= 0.0002;

        composer.render();
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>